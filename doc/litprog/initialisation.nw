## Initialisation

<<cli>>=
let args = docopt(doc)

if args["WEB"]:
  <<handle web-related commands>>

@

<<handle web-related commands>>=
let filename = $(args["WEB"])
let input = newFileStream(filename)
if isNil(input):
  raise newException(IOError, &"failed to open {filename}")
let theWeb = newWeb()
theWeb.read(input)
theWeb.digest()
close(input)

@

<<web>>=
proc newWeb*(): Web =
  new(result)
  result.doc = @[]
  result.code = newTable[string, Clump]();

@

<<web>>=
proc read*(self: Web, input: Stream) =
  var line = 1
  var current = newChunk(line)
  self.doc.add(current)
  while not atEnd(input):
    let text = input.readLine()
    let docChunk = text.match(DOC_HEADER)
    let codeChunk = text.match(CODE_HEADER)
    if isSome(docChunk):
      current = newChunk(line)
      self.doc.add(current)
    elif isSome(codeChunk):
      current = newChunk(line + 1, get(codeChunk).captures[0])
      self.doc.add(current)
    else:
      current.add(text)
    line += 1

@

<<web>>=
proc digest*(self: Web) =
  for chunk in self.doc:
    if chunk.isCode:
      if chunk.name notin self.code:
        self.code[chunk.name] = newClump()
      self.code[chunk.name].add(chunk)
  for includer, clump in self.code:
    for includee in clump.inclusions:
      if includee in self.code:
        self.code[includee].includedBy(includer)

@

<<chunk>>=
proc add*(self: Chunk, text: string) =
  self.body.add(text)

@

<<clump>>=
iterator inclusions*(self: Clump): string =
  for chunk in self.chunks:
    for name in chunk.inclusions:
      yield name

@

<<chunk>>=
iterator inclusions*(self: Chunk): string =
  for line in self.body:
    let codeInclude = line.match(CODE_INCLUDE)
    if isSome(codeInclude):
      yield get(codeInclude).captures[1]

@

<<clump>>=
proc includedBy*(self: Clump, includer: string) =
  self.includers.incl(includer)

@


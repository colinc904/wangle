@page structure

@startuml

class Chunk {
  line
  name
  body
  add(text)
  inclusions()
  isCode()
  newChunk(line, name)
  tangle()
  weave(output)
}

class Clump {
  chunks
  includers
  add(chunk)
  includedBy(includer)
  inclusions()
  isRoot()
  newClump()
  tangle()
}

class Web {
  doc
  code
  digest()
  newWeb()
  read(input)
  roots()
  tangle(name, output)
  tangleClump(name, context, output)
  weave(output)
}

Clump o-- Chunk

Web *-- Clump 
Web *-- Chunk

@enduml## Object Structure

<<web types>>=
type Web* = ref object
  doc: seq[Chunk]
  code: TableRef[string, Clump]

type Context = ref object
  name: string
  line: int
  indent: string
  context: Context

proc newContext(
  name: string,
  line: int,
  indent: string = "",
  context: Context = nil
): Context =
  new(result)
  result.name = name
  result.line = line
  result.indent = indent
  result.context = context

proc contains*(self: Context, name: string): bool =
  if self.name == name:
    return true
  elif self.context.isNil:
    return false
  else:
    return self.context.contains(name)

@

<<clump types>>=
type Clump* = ref object
  chunks:    seq[Chunk]
  includers: HashSet[string]

proc newClump*(): Clump =
  new(result)
  result.chunks = @[]
  result.includers.init()

proc add*(self: Clump, chunk: Chunk) =
  self.chunks.add(chunk)

@

<<chunk types>>=
type Chunk* = ref object
  line:  int
  name*: string
  body:  seq[string]

proc newChunk*(line: int, name: string = ""): Chunk =
  new(result)
  result.line = line
  result.name = name
  result.body = @[]

proc isCode*(self: Chunk): bool =
  result = (len(self.name) > 0)

@

<<tangleresult>>=
type ResultKind* = enum
  simple,
  inclusion

type TangleResult* = object
  case kind*: ResultKind
  of simple:
    text*: string
  of inclusion:
    line*:    int
    indent*:  string
    name*:    string
    postfix*: string

@

